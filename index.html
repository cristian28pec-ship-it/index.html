import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, collection, doc, addDoc, setDoc, deleteDoc, onSnapshot } from 'firebase/firestore';
import { setLogLevel } from 'firebase/firestore';
import { Calendar, MapPin, Tag, Edit, Trash2, CheckCircle, Bell, XCircle, Undo2, Map, Hand, List, Settings, Check, User, Filter, SortAsc, Search, Signal, SignalZero } from 'lucide-react';

// Variables globales para la configuración de Firebase
// Estas variables son proporcionadas automáticamente por el entorno de Canvas
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Inicialización de Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
setLogLevel('debug'); // Habilita el registro de depuración de Firestore

const LOCATION_THRESHOLD = 50; // Umbral de distancia para alertas de ubicación en metros

// Mapeo de días de la semana de español a inglés
const dayMap = { 'Domingo': 0, 'Lunes': 1, 'Martes': 2, 'Miércoles': 3, 'Jueves': 4, 'Viernes': 5, 'Sábado': 6 };
const dayMapReverse = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];

const App = () => {
    // --- State Management ---
    const [userId, setUserId] = useState(null);
    const [reminders, setReminders] = useState([]);
    const [allTags, setAllTags] = useState([]);
    const [newReminderText, setNewReminderText] = useState('');
    const [newReminderTags, setNewReminderTags] = useState('');
    const [isLocationBased, setIsLocationBased] = useState(false);
    const [newLocationName, setNewLocationName] = useState('');
    const [newReminderDate, setNewReminderDate] = useState('');
    const [newReminderTime, setNewReminderTime] = useState('');
    const [alarmSound, setAlarmSound] = useState('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3');
    const [selectedDays, setSelectedDays] = useState([]);
    const [isVibration, setIsVibration] = useState(false);
    const [editingId, setEditingId] = useState(null);
    const [currentLocation, setCurrentLocation] = useState(null);
    const [locationStatus, setLocationStatus] = useState('');
    const [isAlarmModalOpen, setIsAlarmModalOpen] = useState(false);
    const [activeAlarm, setActiveAlarm] = useState(null);
    const [showCompleted, setShowCompleted] = useState(false);
    const [searchText, setSearchText] = useState('');
    const [filterType, setFilterType] = useState('all'); // 'all', 'time', 'location'
    const [sortBy, setSortBy] = useState('createdAt'); // 'createdAt', 'text'
    const [isFirstLaunch, setIsFirstLaunch] = useState(true);
    const [messageModal, setMessageModal] = useState({ isOpen: false, text: '', isError: false });
    const [isOnline, setIsOnline] = useState(navigator.onLine);
    const [repeatFrequency, setRepeatFrequency] = useState('none'); // 'none', 'weekly', 'monthly', 'yearly'

    const alarmAudioRef = useRef(null);
    const watchIdRef = useRef(null);
    const reminderTimeoutsRef = useRef({});

    // --- Lógica de Onboarding ---
    useEffect(() => {
        const hasSeenOnboarding = localStorage.getItem('hasSeenOnboarding');
        if (hasSeenOnboarding) {
            setIsFirstLaunch(false);
        }
    }, []);

    const handleStartApp = () => {
        setIsFirstLaunch(false);
        localStorage.setItem('hasSeenOnboarding', 'true');
        // Solicita permiso de notificaciones al iniciar la app
        if ("Notification" in window) {
            Notification.requestPermission().then(permission => {
                if (permission === "granted") {
                    console.log("Permiso de notificación concedido.");
                } else {
                    console.warn("Permiso de notificación denegado.");
                }
            });
        }
    };

    // --- Autenticación de Firebase y Obtención de Datos ---
    useEffect(() => {
        const unsubscribeAuth = onAuthStateChanged(auth, async (user) => {
            if (user) {
                setUserId(user.uid);
                console.log("Usuario autenticado con ID:", user.uid);
            } else {
                console.log("No hay usuario autenticado, intentando iniciar sesión.");
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Error al iniciar sesión en Firebase:", error.message, error.code);
                }
            }
        });

        // Limpieza del listener de autenticación
        return () => unsubscribeAuth();
    }, []);

    useEffect(() => {
        if (!userId) return;

        const remindersRef = collection(db, `artifacts/${appId}/users/${userId}/reminders`);
        const tagsRef = collection(db, `artifacts/${appId}/users/${userId}/tags`);

        // Sincronizar recordatorios
        const unsubscribeReminders = onSnapshot(remindersRef, (snapshot) => {
            const fetchedReminders = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setReminders(fetchedReminders);
            scheduleTimeAlarms(fetchedReminders);
        }, (error) => {
            console.error("Error al obtener los recordatorios:", error);
        });
        
        // Sincronizar etiquetas
        const unsubscribeTags = onSnapshot(tagsRef, (snapshot) => {
            const fetchedTags = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setAllTags(fetchedTags);
        }, (error) => {
            console.error("Error al obtener las etiquetas:", error);
        });

        // Limpieza de listeners
        return () => {
            unsubscribeReminders();
            unsubscribeTags();
        };
    }, [userId]);
    
    // --- Lógica de Conexión en Línea/Fuera de Línea ---
    useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);

        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        return () => {
            window.removeEventListener('online', handleOnline);
            window.removeEventListener('offline', handleOffline);
        };
    }, []);

    // --- Lógica de Geolocalización ---
    useEffect(() => {
        if (userId) {
            startGeolocationWatch();
        }
        return () => {
            if (watchIdRef.current) {
                navigator.geolocation.clearWatch(watchIdRef.current);
            }
        };
    }, [userId]);

    const startGeolocationWatch = () => {
        if (!('geolocation' in navigator)) {
            setLocationStatus('Geolocalización no soportada en este navegador.');
            return;
        }

        if (watchIdRef.current) {
            navigator.geolocation.clearWatch(watchIdRef.current);
        }

        watchIdRef.current = navigator.geolocation.watchPosition(
            (position) => {
                const { latitude, longitude } = position.coords;
                setCurrentLocation({ latitude, longitude });
                setLocationStatus(`Ubicación actualizada: Lat ${latitude.toFixed(4)}, Lng ${longitude.toFixed(4)}`);
                checkLocationReminders(latitude, longitude);
            },
            (error) => {
                let userFriendlyMessage = "Error al obtener la ubicación.";
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        userFriendlyMessage = "Por favor, permite el acceso a la ubicación en la configuración de tu navegador para usar esta función.";
                        break;
                    case error.POSITION_UNAVAILABLE:
                        userFriendlyMessage = "La información de ubicación no está disponible actualmente.";
                        break;
                    case error.TIMEOUT:
                        userFriendlyMessage = "No se pudo obtener la ubicación a tiempo.";
                        break;
                }
                setLocationStatus(userFriendlyMessage);
                console.error('Error de geolocalización:', error.message || 'Error desconocido', 'Código:', error.code, 'Objeto:', error);
            },
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
        );
    };

    const getCurrentLocation = () => {
        if (!('geolocation' in navigator)) {
            setMessageModal({ isOpen: true, text: 'Geolocalización no soportada en este navegador.', isError: true });
            return;
        }
        setLocationStatus('Obteniendo ubicación...');
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const { latitude, longitude } = position.coords;
                setCurrentLocation({ latitude, longitude });
                setLocationStatus(`Ubicación guardada: Lat ${latitude.toFixed(4)}, Lng ${longitude.toFixed(4)}`);
            },
            (error) => {
                let userFriendlyMessage = "Error al obtener la ubicación.";
                if (error.code === error.PERMISSION_DENIED) {
                    userFriendlyMessage = "Permiso denegado. Por favor, habilita la ubicación en la configuración del navegador.";
                }
                setMessageModal({ isOpen: true, text: userFriendlyMessage, isError: true });
                setLocationStatus(userFriendlyMessage);
                console.error('Error de geolocalización:', error.message || 'Error desconocido', 'Código:', error.code, 'Objeto:', error);
            }
        );
    };

    const checkLocationReminders = (lat, lng) => {
        const locationReminders = reminders.filter(r => r.isLocationBased && !r.isCompleted && !r.isAlarmDismissed);
        locationReminders.forEach(reminder => {
            const distance = haversineDistance(lat, lng, reminder.location.latitude, reminder.location.longitude);
            if (distance <= LOCATION_THRESHOLD) {
                triggerAlarm(reminder.id, reminder);
            }
        });
    };

    const haversineDistance = (lat1, lon1, lat2, lon2) => {
        const toRad = (x) => x * Math.PI / 180;
        const R = 6371e3; // metres
        const φ1 = toRad(lat1);
        const φ2 = toRad(lat2);
        const Δφ = toRad(lat2 - lat1);
        const Δλ = toRad(lon2 - lon1);
        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    };

    // --- Lógica de Alarmas ---
    const scheduleTimeAlarms = (allReminders) => {
        // Limpia todos los temporizadores existentes para evitar duplicados
        for (const timeoutId of Object.values(reminderTimeoutsRef.current)) {
            clearTimeout(timeoutId);
        }
        reminderTimeoutsRef.current = {};

        allReminders.forEach((reminder) => {
            if (!reminder.isCompleted && !reminder.isAlarmDismissed && !reminder.isLocationBased) {
                const nextAlarmTime = findNextAlarmTime(reminder);
                if (nextAlarmTime) {
                    const timeToAlarm = nextAlarmTime.getTime() - new Date().getTime();
                    if (timeToAlarm > 0) {
                        const timeoutId = setTimeout(() => {
                            triggerAlarm(reminder.id, reminder);
                        }, timeToAlarm);
                        reminderTimeoutsRef.current[reminder.id] = timeoutId;
                    }
                }
            }
        });
    };
    
    // Función para encontrar la próxima fecha de alarma basándose en la repetición
    const findNextAlarmTime = (reminder) => {
        const now = new Date();
        const [alarmHour, alarmMinute] = reminder.time.split(':').map(Number);
        
        // Si no hay fecha o tiempo, no se puede programar
        if (!reminder.date || !reminder.time) {
            return null;
        }

        const reminderDate = new Date(`${reminder.date}T${reminder.time}`);
        
        let nextOccurrence = null;

        if (reminder.repeatFrequency === 'none') {
            nextOccurrence = reminderDate;
            if (now > nextOccurrence) {
                return null;
            }
        } else if (reminder.repeatFrequency === 'weekly' && reminder.selectedDays) {
            const sortedDays = reminder.selectedDays.map(day => dayMap[day]).sort((a, b) => a - b);
            
            let nextDayDiff = -1;
            const nowDay = now.getDay();
            const nowTimeInMinutes = now.getHours() * 60 + now.getMinutes();
            const alarmTimeInMinutes = alarmHour * 60 + alarmMinute;

            for (const day of sortedDays) {
                if (day > nowDay || (day === nowDay && alarmTimeInMinutes > nowTimeInMinutes)) {
                    nextDayDiff = day - nowDay;
                    break;
                }
            }

            if (nextDayDiff === -1) {
                nextDayDiff = 7 + sortedDays[0] - nowDay;
            }
            
            nextOccurrence = new Date(now);
            nextOccurrence.setDate(now.getDate() + nextDayDiff);
            nextOccurrence.setHours(alarmHour, alarmMinute, 0, 0);
            
        } else if (reminder.repeatFrequency === 'monthly') {
            const reminderDayOfMonth = reminderDate.getDate();
            nextOccurrence = new Date(now.getFullYear(), now.getMonth(), reminderDayOfMonth, alarmHour, alarmMinute);
            if (now > nextOccurrence) {
                nextOccurrence.setMonth(now.getMonth() + 1);
            }
        } else if (reminder.repeatFrequency === 'yearly') {
            const reminderMonth = reminderDate.getMonth();
            const reminderDayOfMonth = reminderDate.getDate();
            nextOccurrence = new Date(now.getFullYear(), reminderMonth, reminderDayOfMonth, alarmHour, alarmMinute);
            if (now > nextOccurrence) {
                nextOccurrence.setFullYear(now.getFullYear() + 1);
            }
        }
        
        if (nextOccurrence && isNaN(nextOccurrence.getTime())) {
            console.error("Fecha de alarma inválida, no se pudo programar:", reminder);
            return null;
        }
        
        return nextOccurrence;
    };

    const triggerAlarm = (id, data) => {
        if (activeAlarm) return; // Evita múltiples alarmas a la vez
        setActiveAlarm(data);
        setIsAlarmModalOpen(true);

        const { text, sound, isVibration } = data;
        
        if ("Notification" in window && Notification.permission === "granted") {
            new Notification('Recordatorio', { body: text });
        }
        
        if (alarmAudioRef.current && sound) {
            alarmAudioRef.current.src = sound;
            alarmAudioRef.current.load();
            alarmAudioRef.current.play();
        }
        
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'es-ES';
            window.speechSynthesis.speak(utterance);
        }
        
        if (isVibration && 'vibrate' in navigator) {
            navigator.vibrate([1000, 500, 1000, 500, 1000]);
        }

        const reminderRef = doc(db, `artifacts/${appId}/users/${userId}/reminders`, id);
        setDoc(reminderRef, { isAlarmDismissed: false }, { merge: true });
    };

    const stopAlarm = () => {
        if (alarmAudioRef.current) {
            alarmAudioRef.current.pause();
            alarmAudioRef.current.currentTime = 0;
        }
        if ('vibrate' in navigator) navigator.vibrate(0);
        if ('speechSynthesis' in window) window.speechSynthesis.cancel();

        const reminderRef = doc(db, `artifacts/${appId}/users/${userId}/reminders`, activeAlarm.id);
        setDoc(reminderRef, { isAlarmDismissed: true }, { merge: true });

        setIsAlarmModalOpen(false);
        setActiveAlarm(null);
    };

    const snoozeAlarm = () => {
        stopAlarm();
        if (activeAlarm) {
            const newTime = new Date(new Date().getTime() + 5 * 60000);
            const reminderRef = doc(db, `artifacts/${appId}/users/${userId}/reminders`, activeAlarm.id);
            setDoc(reminderRef, {
                date: newTime.toISOString().split('T')[0],
                time: newTime.toTimeString().split(' ')[0].substring(0, 5),
                isAlarmDismissed: false,
                repeatFrequency: 'none',
                isLocationBased: false
            }, { merge: true });
        }
    };
    
    // --- Operaciones CRUD ---
    const saveReminder = async () => {
        if (!userId) {
            console.error("Usuario no autenticado, no se puede guardar el recordatorio.");
            return;
        }

        const text = newReminderText.trim();
        const tags = newReminderTags.split('#').map(tag => tag.trim()).filter(tag => tag);
        let reminderData;

        if (isLocationBased) {
            if (!text || !newLocationName || !currentLocation) {
                setMessageModal({ isOpen: true, text: 'Por favor, rellena el texto y el nombre del lugar, y asegúrate de que tu ubicación esté disponible.', isError: true });
                return;
            }
            reminderData = {
                text,
                tags,
                location: { name: newLocationName, latitude: currentLocation.latitude, longitude: currentLocation.longitude },
                isLocationBased,
                isVibration,
                isCompleted: false,
                isAlarmDismissed: false,
                createdAt: new Date().toISOString()
            };
        } else {
            if (!text || !newReminderTime || (repeatFrequency === 'none' && !newReminderDate)) {
                 setMessageModal({ isOpen: true, text: 'Por favor, rellena el texto, la hora, y la fecha si no hay repetición.', isError: true });
                 return;
            }
            reminderData = {
                text,
                tags,
                date: newReminderDate,
                time: newReminderTime,
                sound: alarmSound,
                repeatFrequency,
                selectedDays: repeatFrequency === 'weekly' ? selectedDays : [],
                isLocationBased,
                isVibration,
                isCompleted: false,
                isAlarmDismissed: false,
                createdAt: new Date().toISOString()
            };
        }

        try {
            if (editingId) {
                const reminderRef = doc(db, `artifacts/${appId}/users/${userId}/reminders`, editingId);
                await setDoc(reminderRef, { ...reminderData, isAlarmDismissed: false }, { merge: true });
            } else {
                const reminderRef = collection(db, `artifacts/${appId}/users/${userId}/reminders`);
                await addDoc(reminderRef, reminderData);
            }
            // Guarda las nuevas etiquetas creadas
            const newTags = tags.filter(tag => !allTags.some(t => t.name === tag));
            await Promise.all(newTags.map(tag => {
                const tagRef = doc(db, `artifacts/${appId}/users/${userId}/tags`, tag);
                return setDoc(tagRef, { name: tag });
            }));
            
            setMessageModal({ isOpen: true, text: '¡Recordatorio guardado con éxito!', isError: false });
            resetForm();
        } catch (e) {
            console.error("Error al guardar/actualizar el recordatorio:", e);
            setMessageModal({ isOpen: true, text: 'Error al guardar el recordatorio. Por favor, inténtalo de nuevo.', isError: true });
        }
    };

    const deleteReminder = async (id) => {
        try {
            await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/reminders`, id));
            setMessageModal({ isOpen: true, text: '¡Recordatorio eliminado!', isError: false });
        } catch (e) {
            console.error("Error al eliminar el recordatorio:", e);
            setMessageModal({ isOpen: true, text: 'Error al eliminar el recordatorio. Por favor, inténtalo de nuevo.', isError: true });
        }
    };

    const markAsComplete = async (id) => {
        try {
            const reminderRef = doc(db, `artifacts/${appId}/users/${userId}/reminders`, id);
            await setDoc(reminderRef, { isCompleted: true }, { merge: true });
            setMessageModal({ isOpen: true, text: '¡Recordatorio completado!', isError: false });
        } catch (e) {
            console.error("Error al marcar como completado:", e);
            setMessageModal({ isOpen: true, text: 'Error al completar el recordatorio. Por favor, inténtalo de nuevo.', isError: true });
        }
    };

    const unmarkAsComplete = async (id) => {
        try {
            const reminderRef = doc(db, `artifacts/${appId}/users/${userId}/reminders`, id);
            await setDoc(reminderRef, { isCompleted: false }, { merge: true });
            setMessageModal({ isOpen: true, text: '¡Recordatorio restaurado!', isError: false });
        } catch (e) {
            console.error("Error al restaurar el recordatorio:", e);
            setMessageModal({ isOpen: true, text: 'Error al restaurar el recordatorio. Por favor, inténtalo de nuevo.', isError: true });
        }
    };

    const editReminder = (reminder) => {
        setEditingId(reminder.id);
        setNewReminderText(reminder.text);
        setNewReminderTags(reminder.tags.join(' '));
        setIsVibration(reminder.isVibration);
        setIsLocationBased(reminder.isLocationBased);

        if (reminder.isLocationBased) {
            setNewLocationName(reminder.location.name);
            setCurrentLocation({ latitude: reminder.location.latitude, longitude: reminder.location.longitude });
            setLocationStatus(`Lat: ${reminder.location.latitude.toFixed(4)}, Lng: ${reminder.location.longitude.toFixed(4)}`);
        } else {
            setNewReminderDate(reminder.date);
            setNewReminderTime(reminder.time);
            setAlarmSound(reminder.sound);
            setSelectedDays(reminder.selectedDays || []);
            setRepeatFrequency(reminder.repeatFrequency || 'none');
        }
    };

    const resetForm = () => {
        setEditingId(null);
        setNewReminderText('');
        setNewReminderTags('');
        setNewLocationName('');
        setIsLocationBased(false);
        setNewReminderDate('');
        setNewReminderTime('');
        setAlarmSound('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3');
        setSelectedDays([]);
        setIsVibration(false);
        setLocationStatus('');
        setRepeatFrequency('none');
    };
    
    const deleteTag = async (tagId) => {
      try {
        await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/tags`, tagId));
      } catch (e) {
        console.error("Error al eliminar la etiqueta:", e);
        setMessageModal({ isOpen: true, text: 'Error al eliminar la etiqueta. Por favor, inténtalo de nuevo.', isError: true });
      }
    };

    const handleDayToggle = (day) => {
        setSelectedDays(prev => prev.includes(day) ? prev.filter(d => d !== day) : [...prev, day]);
    };

    const handleTagClick = (tag) => {
      const currentTags = newReminderTags.split(' ').filter(t => t.trim() !== '');
      if (!currentTags.includes(tag.name)) {
        setNewReminderTags(prev => prev ? `${prev} #${tag.name}` : `#${tag.name}`);
      }
    };

    // --- Lógica de filtrado y ordenamiento ---
    const getFilteredAndSortedReminders = () => {
        let list = [...reminders];

        // 1. Filtrar por texto y etiquetas
        list = list.filter(r => {
            const textMatch = r.text.toLowerCase().includes(searchText.toLowerCase());
            const tagsMatch = r.tags.some(tag => tag.toLowerCase().includes(searchText.toLowerCase()));
            return textMatch || tagsMatch;
        });

        // 2. Filtrar por tipo
        if (filterType === 'time') {
            list = list.filter(r => !r.isLocationBased);
        } else if (filterType === 'location') {
            list = list.filter(r => r.isLocationBased);
        }

        // 3. Ordenar en el cliente (para evitar errores de índice de Firestore)
        if (sortBy === 'createdAt') {
            list.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        } else if (sortBy === 'text') {
            list.sort((a, b) => a.text.localeCompare(b.text));
        }

        return list;
    };
    
    const allFilteredReminders = getFilteredAndSortedReminders();
    const pendingReminders = allFilteredReminders.filter(r => !r.isCompleted);
    const completedReminders = allFilteredReminders.filter(r => r.isCompleted);
    
    // Check if the save button should be enabled
    const isSaveDisabled = isLocationBased
        ? !newReminderText || !newLocationName || !currentLocation
        : !newReminderText || !newReminderTime || (repeatFrequency === 'none' && !newReminderDate) || (repeatFrequency === 'weekly' && selectedDays.length === 0);

    // --- Renderización de Componentes ---
    const renderReminderItem = (reminder) => (
        <div key={reminder.id} className={`bg-white rounded-xl shadow-md p-4 flex justify-between items-start transition-all duration-300 transform hover:scale-[1.02] mb-3 ${reminder.isCompleted ? 'opacity-70 border-l-4 border-gray-300' : 'border-l-4 border-blue-500'}`}>
            <div className="flex-1">
                <p className={`text-lg text-gray-800 font-semibold ${reminder.isCompleted ? 'line-through text-gray-400' : ''}`}>{reminder.text}</p>
                {reminder.isLocationBased ? (
                    <>
                        <p className="text-sm text-gray-500 mt-1 flex items-center gap-1"><MapPin size={14} /> Lugar: {reminder.location.name}</p>
                        <p className="text-xs text-gray-400 mt-1">Ubicación: {reminder.location.latitude.toFixed(4)}, {reminder.location.longitude.toFixed(4)}</p>
                    </>
                ) : (
                    <>
                        {reminder.repeatFrequency === 'none' && reminder.date && (
                            <p className="text-sm text-gray-500 mt-1 flex items-center gap-1"><Calendar size={14} /> Fecha: {new Date(`${reminder.date}T${reminder.time}`).toLocaleString('es-ES', { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' })}</p>
                        )}
                        {reminder.repeatFrequency === 'weekly' && reminder.selectedDays && reminder.selectedDays.length > 0 && (
                            <p className="text-sm text-gray-500 mt-1 flex items-center gap-1"><Calendar size={14} /> Semanal: {reminder.selectedDays.map(day => dayMapReverse[dayMap[day]]).join(', ')} a las {reminder.time}</p>
                        )}
                        {reminder.repeatFrequency === 'monthly' && reminder.date && (
                            <p className="text-sm text-gray-500 mt-1 flex items-center gap-1"><Calendar size={14} /> Mensual: El día {new Date(reminder.date).getDate()} a las {reminder.time}</p>
                        )}
                        {reminder.repeatFrequency === 'yearly' && reminder.date && (
                            <p className="text-sm text-gray-500 mt-1 flex items-center gap-1"><Calendar size={14} /> Anual: El {new Date(reminder.date).toLocaleDateString('es-ES', { month: 'long', day: 'numeric' })} a las {reminder.time}</p>
                        )}
                    </>
                )}
                <div className="mt-2 flex flex-wrap gap-2">
                    {reminder.tags.map((tag, index) => (
                        <span key={index} className="bg-gray-200 text-gray-700 text-xs px-2 py-1 rounded-full font-semibold flex items-center gap-1"><Tag size={12} />#{tag}</span>
                    ))}
                </div>
            </div>
            <div className="flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-2 ml-4">
                {!reminder.isCompleted && (
                    <button onClick={() => editReminder(reminder)} className="text-gray-400 hover:text-blue-500 transition-colors p-2 rounded-full hover:bg-gray-100">
                        <Edit size={20} />
                    </button>
                )}
                <button onClick={() => reminder.isCompleted ? unmarkAsComplete(reminder.id) : markAsComplete(reminder.id)} className={`transition-colors p-2 rounded-full hover:bg-gray-100 ${reminder.isCompleted ? 'text-blue-500 hover:text-blue-700' : 'text-green-500 hover:text-green-700'}`}>
                    {reminder.isCompleted ? <Undo2 size={20} /> : <CheckCircle size={20} />}
                </button>
                <button onClick={() => deleteReminder(reminder.id)} className="text-gray-400 hover:text-red-500 transition-colors p-2 rounded-full hover:bg-gray-100">
                    <Trash2 size={20} />
                </button>
            </div>
        </div>
    );
    
    // --- Renderización de la App Principal o la Pantalla de Onboarding ---
    const renderOnboarding = () => (
        <div className="flex flex-col items-center justify-center p-8 text-center min-h-screen bg-gray-50">
            <h1 className="text-5xl sm:text-6xl font-extrabold text-blue-600 mb-4 animate-fade-in-up">Recordatorios</h1>
            <p className="text-xl sm:text-2xl text-gray-700 mb-8 max-w-lg animate-fade-in-up">Tu asistente personal para recordar todo, en cualquier momento y lugar.</p>
            <div className="grid grid-cols-1 sm:grid-cols-3 gap-6 mb-12 max-w-xl">
                <div className="flex flex-col items-center p-4 bg-white rounded-xl shadow-lg">
                    <Calendar size={48} className="text-blue-500 mb-2" />
                    <span className="font-semibold text-gray-800">Recordatorios por fecha</span>
                </div>
                <div className="flex flex-col items-center p-4 bg-white rounded-xl shadow-lg">
                    <MapPin size={48} className="text-blue-500 mb-2" />
                    <span className="font-semibold text-gray-800">Alertas por ubicación</span>
                </div>
                <div className="flex flex-col items-center p-4 bg-white rounded-xl shadow-lg">
                    <Tag size={48} className="text-blue-500 mb-2" />
                    <span className="font-semibold text-gray-800">Etiquetas personalizadas</span>
                </div>
            </div>
            <button onClick={handleStartApp} className="w-full max-w-sm bg-blue-600 text-white font-bold py-4 px-8 rounded-full hover:bg-blue-700 transition-colors shadow-lg animate-fade-in-up">
                Comenzar
            </button>
        </div>
    );
    
    const renderMainApp = () => (
        <div className="p-4 sm:p-8 flex flex-col items-center min-h-screen bg-gray-50">
            <div className="w-full max-w-2xl">
                <div className="flex justify-between items-center mb-6">
                    <h1 className="text-4xl sm:text-5xl font-bold text-gray-800 text-center flex-1">Recordatorios</h1>
                    <div className="flex items-center space-x-2 text-gray-500">
                        {isOnline ? (
                          <div className="flex items-center space-x-1">
                            <Signal size={20} className="text-green-500" />
                            <span className="text-sm hidden sm:inline">Online</span>
                          </div>
                        ) : (
                          <div className="flex items-center space-x-1">
                            <SignalZero size={20} className="text-red-500" />
                            <span className="text-sm hidden sm:inline">Offline</span>
                          </div>
                        )}
                    </div>
                </div>

                {userId && (
                    <div className="flex items-center justify-center space-x-2 text-sm text-gray-500 mb-4">
                        <User size={16} />
                        <span className="truncate">ID de Usuario: {userId}</span>
                    </div>
                )}

                {/* Contenedor de Anuncios - Coloca aquí el código de tu red publicitaria */}
                <div className="w-full h-32 bg-gray-200 rounded-xl flex items-center justify-center border-dashed border-2 border-gray-400 mb-6">
                    <p className="text-gray-500 text-sm">Espacio para anuncio</p>
                </div>
                
                <div className="reminder-card p-6 mb-8 shadow-lg bg-white rounded-3xl">
                    <h2 className="text-xl font-semibold text-gray-800 mb-4">{editingId ? 'Editar Recordatorio' : 'Crear un Nuevo Recordatorio'}</h2>
                    
                    <div className="space-y-4">
                        <input
                            type="text"
                            value={newReminderText}
                            onChange={(e) => setNewReminderText(e.target.value)}
                            placeholder="Ej: Comprar leche, Llamar a Juan"
                            className="w-full p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500"
                        />
                        <input
                            type="text"
                            value={newReminderTags}
                            onChange={(e) => setNewReminderTags(e.target.value)}
                            placeholder="Ej: #compras #casa"
                            className="w-full p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500"
                        />
                        <div className="flex flex-wrap gap-2 mb-2">
                            {allTags.map(tag => (
                                <button
                                    key={tag.id}
                                    onClick={() => handleTagClick(tag)}
                                    className="bg-blue-100 text-blue-800 text-sm px-3 py-1 rounded-full font-semibold transition-colors hover:bg-blue-200"
                                >
                                    #{tag.name}
                                </button>
                            ))}
                        </div>
                        <div className="flex items-center space-x-4">
                            <label className="flex items-center cursor-pointer text-gray-700 font-medium">
                                <input
                                    type="checkbox"
                                    checked={isLocationBased}
                                    onChange={() => setIsLocationBased(!isLocationBased)}
                                    className="form-checkbox h-5 w-5 text-blue-600 rounded-md"
                                />
                                <span className="ml-2">Basado en ubicación</span>
                            </label>
                            <label className="flex items-center cursor-pointer text-gray-700 font-medium">
                                <input
                                    type="checkbox"
                                    checked={isVibration}
                                    onChange={() => setIsVibration(!isVibration)}
                                    className="form-checkbox h-5 w-5 text-blue-600 rounded-md"
                                />
                                <span className="ml-2">Vibrar</span>
                            </label>
                        </div>
                        {isLocationBased ? (
                            <div className="space-y-4">
                                <input
                                    type="text"
                                    value={newLocationName}
                                    onChange={(e) => setNewLocationName(e.target.value)}
                                    placeholder="Ej: Supermercado, Casa de la abuela"
                                    className="w-full p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500"
                                />
                                <button
                                    onClick={getCurrentLocation}
                                    className="w-full bg-yellow-500 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-yellow-600 transition-colors"
                                >
                                    <MapPin size={20} className="inline-block mr-2" />
                                    Obtener mi ubicación actual
                                </button>
                                {locationStatus && (
                                    <p className="text-sm text-gray-500 mt-2 text-center">{locationStatus}</p>
                                )}
                            </div>
                        ) : (
                            <div className="space-y-4">
                                <input
                                    type="date"
                                    value={newReminderDate}
                                    onChange={(e) => setNewReminderDate(e.target.value)}
                                    className="w-full p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500"
                                />
                                <input
                                    type="time"
                                    value={newReminderTime}
                                    onChange={(e) => setNewReminderTime(e.target.value)}
                                    className="w-full p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500"
                                />
                                <select
                                    value={alarmSound}
                                    onChange={(e) => setAlarmSound(e.target.value)}
                                    className="w-full p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500"
                                >
                                    <option value="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3">Melodía 1</option>
                                    <option value="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3">Melodía 2</option>
                                    <option value="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3">Melodía 3</option>
                                </select>
                                <div className="space-y-2">
                                    <p className="text-gray-700 font-medium">Frecuencia de Repetición:</p>
                                    <div className="flex flex-wrap gap-2">
                                        <button onClick={() => setRepeatFrequency('none')} className={`px-4 py-2 rounded-full text-sm font-semibold transition-colors ${repeatFrequency === 'none' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}>Ninguna</button>
                                        <button onClick={() => setRepeatFrequency('weekly')} className={`px-4 py-2 rounded-full text-sm font-semibold transition-colors ${repeatFrequency === 'weekly' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}>Semanal</button>
                                        <button onClick={() => setRepeatFrequency('monthly')} className={`px-4 py-2 rounded-full text-sm font-semibold transition-colors ${repeatFrequency === 'monthly' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}>Mensual</button>
                                        <button onClick={() => setRepeatFrequency('yearly')} className={`px-4 py-2 rounded-full text-sm font-semibold transition-colors ${repeatFrequency === 'yearly' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}>Anual</button>
                                    </div>
                                    {repeatFrequency === 'weekly' && (
                                        <div className="flex flex-wrap gap-2 mt-2">
                                            {dayMapReverse.map(day => (
                                                <button
                                                    key={day}
                                                    onClick={() => handleDayToggle(day)}
                                                    className={`w-10 h-10 rounded-full flex items-center justify-center font-bold text-sm transition-colors ${selectedDays.includes(day) ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}
                                                >
                                                    {day.substring(0, 1)}
                                                </button>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        )}
                        <div className="flex space-x-2">
                            <button
                                onClick={saveReminder}
                                disabled={isSaveDisabled}
                                className={`flex-1 flex items-center justify-center py-3 px-6 rounded-lg font-bold transition-all duration-300 transform hover:scale-105 shadow-md ${isSaveDisabled ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 text-white hover:bg-blue-700'}`}
                            >
                                <Check size={20} className="inline-block mr-2" />
                                {editingId ? 'Actualizar' : 'Guardar'}
                            </button>
                            {editingId && (
                                <button
                                    onClick={resetForm}
                                    className="flex-1 flex items-center justify-center py-3 px-6 rounded-lg font-bold text-gray-600 bg-gray-200 hover:bg-gray-300 transition-colors shadow-md"
                                >
                                    <XCircle size={20} className="inline-block mr-2" />
                                    Cancelar
                                </button>
                            )}
                        </div>
                    </div>
                </div>

                {/* Seccion de Recordatorios Pendientes */}
                <h2 className="text-2xl font-semibold text-gray-800 mt-8 mb-4">Recordatorios Pendientes</h2>
                <div className="space-y-4">
                    {pendingReminders.length > 0 ? (
                        pendingReminders.map(renderReminderItem)
                    ) : (
                        <div className="text-center text-gray-500 p-6 bg-white rounded-xl shadow-md">
                            No hay recordatorios pendientes. ¡Crea uno!
                        </div>
                    )}
                </div>

                {/* Seccion de Recordatorios Completados */}
                <div className="mt-8 mb-4 flex justify-between items-center">
                    <h2 className="text-2xl font-semibold text-gray-800">Recordatorios Completados</h2>
                    <button onClick={() => setShowCompleted(!showCompleted)} className="text-blue-600 hover:text-blue-700 transition-colors font-medium">
                        {showCompleted ? 'Ocultar' : 'Mostrar'}
                    </button>
                </div>
                {showCompleted && (
                    <div className="space-y-4 mt-4">
                        {completedReminders.length > 0 ? (
                            completedReminders.map(renderReminderItem)
                        ) : (
                            <div className="text-center text-gray-500 p-6 bg-white rounded-xl shadow-md">
                                No hay recordatorios completados.
                            </div>
                        )}
                    </div>
                )}
            </div>

            {/* Modal de Alarma */}
            {isAlarmModalOpen && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                    <div className="bg-white p-8 rounded-2xl shadow-xl max-w-sm w-full text-center transform scale-100 transition-transform duration-300">
                        <Bell size={64} className="text-blue-500 mx-auto mb-4 animate-bounce-custom" />
                        <h3 className="text-2xl font-bold text-gray-800 mb-2">¡Recordatorio!</h3>
                        <p className="text-lg text-gray-600 mb-6">{activeAlarm?.text}</p>
                        <div className="flex flex-col space-y-4">
                            <button onClick={snoozeAlarm} className="bg-yellow-500 text-white font-bold py-3 rounded-lg shadow-md hover:bg-yellow-600 transition-colors">Posponer (5 min)</button>
                            <button onClick={stopAlarm} className="bg-red-500 text-white font-bold py-3 rounded-lg shadow-md hover:bg-red-600 transition-colors">Descartar</button>
                        </div>
                    </div>
                </div>
            )}
            
            {/* Modal de Mensajes */}
            {messageModal.isOpen && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                    <div className="bg-white p-6 rounded-2xl shadow-xl max-w-xs w-full text-center">
                        <div className={`mx-auto mb-4 ${messageModal.isError ? 'text-red-500' : 'text-green-500'}`}>
                            {messageModal.isError ? <XCircle size={48} /> : <CheckCircle size={48} />}
                        </div>
                        <p className="text-md text-gray-700 font-semibold">{messageModal.text}</p>
                        <button onClick={() => setMessageModal({ ...messageModal, isOpen: false })} className="mt-4 bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors">
                            Cerrar
                        </button>
                    </div>
                </div>
            )}
            
            <audio ref={alarmAudioRef} loop></audio>
        </div>
    );

    return isFirstLaunch ? renderOnboarding() : renderMainApp();
};

export default App;
